{"version":3,"sources":["../../src/crypto/interface.ts","../../src/crypto/node.ts"],"names":["createHmac","createHash","nodeRandomBytes","timingSafeEqual"],"mappings":"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","file":"node.cjs","sourcesContent":["/**\n * @file crypto/interface.ts\n * @description Unified crypto provider interface.\n * Implementations: node.ts (Node/Bun/Deno), web.ts (Browser/React Native).\n *\n * Copyright (c) 2026 Hestia Labs\n * SDK-License-Identifier: MIT\n */\n\nexport interface CryptoProvider {\n    /**\n     * Compute HMAC-SHA256 and return lowercase hex string (64 chars).\n     * @param secret - Raw secret bytes.\n     * @param data - UTF-8 string to sign.\n     */\n    signHmacSha256(secret: Uint8Array, data: string): Promise<string>;\n\n    /**\n     * Compute SHA-256 hash and return lowercase hex string (64 chars).\n     * @param data - UTF-8 string to hash.\n     */\n    sha256Hex(data: string): Promise<string>;\n\n    /**\n     * Generate cryptographically secure random bytes.\n     * @param length - Number of bytes.\n     */\n    randomBytes(length: number): Uint8Array;\n}\n\n/**\n * Constant-time string comparison.\n * Safe for comparing HMAC hex digests — prevents timing side-channels.\n * Platform-independent: does NOT rely on crypto.timingSafeEqual.\n */\nexport function constantTimeEqual(a: string, b: string): boolean {\n    if (a.length !== b.length) return false;\n\n    let diff = 0;\n    for (let i = 0; i < a.length; i++) {\n        diff |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n    return diff === 0;\n}\n\n/** Convert Uint8Array to lowercase hex string. */\nexport function bytesToHex(bytes: Uint8Array): string {\n    const hex: string[] = [];\n    for (let i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i]! >>> 4).toString(16));\n        hex.push((bytes[i]! & 0x0f).toString(16));\n    }\n    return hex.join(\"\");\n}\n\n/** Convert hex string to Uint8Array. */\nexport function hexToBytes(hex: string): Uint8Array {\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string length\");\n    }\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n    return bytes;\n}\n","/**\n * @file crypto/node.ts\n * @description Node.js / Bun / Deno crypto provider using native `node:crypto`.\n *\n * Copyright (c) 2026 Hestia Labs\n * SDK-License-Identifier: MIT\n */\n\nimport {\n    createHmac,\n    createHash,\n    randomBytes as nodeRandomBytes,\n    timingSafeEqual,\n} from \"node:crypto\";\nimport type { CryptoProvider } from \"./interface.js\";\nimport { bytesToHex } from \"./interface.js\";\n\nexport { constantTimeEqual, hexToBytes, bytesToHex } from \"./interface.js\";\n\nclass NodeCryptoProvider implements CryptoProvider {\n    async signHmacSha256(secret: Uint8Array, data: string): Promise<string> {\n        const hmac = createHmac(\"sha256\", secret);\n        hmac.update(data, \"utf8\");\n        return hmac.digest(\"hex\");\n    }\n\n    async sha256Hex(data: string): Promise<string> {\n        const hash = createHash(\"sha256\");\n        hash.update(data, \"utf8\");\n        return hash.digest(\"hex\");\n    }\n\n    randomBytes(length: number): Uint8Array {\n        return new Uint8Array(nodeRandomBytes(length));\n    }\n}\n\n/** Singleton Node.js crypto provider. */\nexport const nodeCrypto: CryptoProvider = new NodeCryptoProvider();\n\n/**\n * Constant-time comparison using Node.js `timingSafeEqual`.\n * Preferred over the platform-agnostic version when available.\n * Uses static ESM import — no CJS require() leakage.\n */\nexport function nodeConstantTimeEqual(a: string, b: string): boolean {\n    if (a.length !== b.length) return false;\n    return timingSafeEqual(Buffer.from(a, \"utf8\"), Buffer.from(b, \"utf8\"));\n}\n\n/**\n * Generate a nonce as hex string (min 16 raw bytes → 32 hex chars).\n */\nexport function generateNonce(byteLength: number = 16): string {\n    const bytes = nodeRandomBytes(byteLength);\n    return bytesToHex(new Uint8Array(bytes));\n}\n"]}